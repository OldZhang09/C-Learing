//#include<iostream>;
//using namespace std;
//
//class Base {
//public:
//	Base() {
//		cout << "Base 的构造函数执行" << endl;
//	}
//
//	void Set() {
//		cout << "Base Set" << endl;
//	}
//
//	~Base() {
//		cout << "Base 的析构函数执行" << endl;
//	}
//};
//
//class A :public Base {
//public:
//	A() {
//		cout << "A 的构造函数执行" << endl;
//	}
//	void Set() {
//		cout << "A Set" << endl;
//	}
//
//	~A() {
//		cout << "A 的析构函数执行" << endl;
//	}
//};
////该案例中，p2以Base类型去声明，此时p2发生了静态绑定，即使p2实际上一个A对象，但是因为他被静态绑定了类型Base
//// 所以p2会调用Base set,析构函数同理，A的析构这里不会被调用。
////以上发生的案例称之为多态 为了解决多态我们需要用到虚函数，详见02
//
// 
//void test() {
//	//Base* p = new Base;
//	//p->Set();
//	Base* p2 = new A;
//	p2->Set();
//	delete p2;
//	//分析输出结果，我们看到子类的析构没有执行，为什么New了一个子类A，却调用了Base的函数，此时发生了早捆绑（静态绑定，编译程时，根据调用就可以确定程序运行时调用函数的地址）可以这么理解，在编译器就已经由Base类型决定了调用的成员函数地址。
//	//在析构里我们通常会delete那些不再使用的指针，这里的子类析构没有发生，就会造成内存泄漏
//	//我们要解决这个问题就需要使用虚函数来实现 多态（动态绑定、晚捆绑，在编译程序时，无法确定调用函数的地址，只有运行时通过对象自带信息计算调用函数地址）
//	/*************重要提示，c++中构造函数被禁止使用多态，例如该案例中Base和A的构造函数都被执行了，构造函数体内的多态都不会发生，构造函数本身也不能为虚函数
//	原因深入了解参照 ：https://zhuanlan.zhihu.com/p/368257182          ***************/
//}
//int main() {
//	test();
//	system("pause");
//	return 0;
//}