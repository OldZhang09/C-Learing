//#include<iostream>;
//using namespace std;
//
//int main() {
//	//先记住两条重要准则：1.什么是类型？类型的字节数代表着一个对象从其首地址的跳跃能力，跳跃能力指 指针+1的结果
//	//					  2.一个对象的指针+1的结果是 加上 这个该对象的类型的字节数（符合第一条准则）
//	//案例如下
//	//现象1：数组名、数组名引用、数组第一个元素引用 输出结果一样
//	//分析及结论：数组名及代表数组的首地址，也是第一个元素的首地址，这个没问题
//	//现象2： 第一个元素地址+1、第二个元素地址 ，相同
//	//分析及结论：数组本质也是一种类型，数组的元素其实就是加了索引的成员变量（这样理解是否妥当，没有深入）
//	//			  第一个元素是个int类型（实际上每个成员都是int类型），按照准则，第一个元素的地址+1，地址跳跃的长度等于类型的字节数（int类型为4）
//	//			  刚好是第二个元素的首地址
//	//现象3：数组名+1 =  第二个元素地址
//	//分析及结论：这说明了数组名arr这个指针，他绑定的类型是int，而不是整个数组，所以他的跳跃能力为int的字节数4
//	//现象4：数组名引用 + 1 = 首地址 + 16（数组的总字节数 及 int长度*4）
//	//分析及结论：&arr也是指针，arr也是指针，那为什么他们指向同一个地址，+1的结果不一样呢？
//	//			  这就是所谓的跳跃能力的不同，而跳跃能力是指针的类型决定的，arr绑定的类型为int，能力为4，而&arr绑定的类型为数组，跳跃能力为数组总长，这也是为什么(void*类型)不能+1
//	//总结：只有在1.  “ sizeof ( 数组名 )”（注意括号中只有数组名，并不是含有数组名的表达式），2. “&数组名 ”这两种特殊情况下，数组名的类型属性为数组原本的属性。  
//	//			其余情况下，数组名的类型属性为指向数组首元素的指针类型。
//	int arr[4] = {1,2,3,4};
//	cout << "数组名第一个元素地址 :" << &arr[0] << endl;
//	cout << "数组名第二个元素地址 :" << &arr[1] << endl;
//	cout << "数组名第一个元素地址+1 :" << &arr[0]+1 << endl;
//	cout << "数组名arr :" << arr << endl;
//	cout << "数组名的引用&arr :" << &arr << endl;
//	cout << "数组名arr+1:" << arr+1 << endl;
//	cout << "数组名的引用&arr+1:" << &arr+1 << endl;
//	system("pause");
//	return 0;
//}